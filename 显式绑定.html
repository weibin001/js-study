<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
	</body>
</html>
<script>
//	function foo(){
//		console.log(this.a)
//	}
//	var obj ={
//		a:2,
//	}
//	
//	var bar = function(){
//		foo.call(obj)
//	}
//	
//	bar()


//	function foo(a){
//		console.log(this.a,a);
//		return this.a+a;
//	}
//	
//	var obj = {
//		a:2
//	};
//	var bar = function(){
//		return foo.apply(obj,arguments)
//	};
//	
//	var b = bar(3);
//	console.log(b)

/****************创建可复用的辅助函数**********************/
//
//	function foo(a){
//		console.log(this.a,a);
//		return this.a + a;
//	}
//	/**重点**/
//	function bind(fn,obj){
//		return function(){
//			return fn.apply(obj,arguments);
//		}
//	}
//	var obj = {
//		a:2
//	}
//	var bar = bind(foo,obj);
//	var b = bar(3);
//	console.log(b)

/***************new绑定和隐式绑定比较优先级**********************/
//	function foo(something){
//		this.a = something
//		console.log(this.a)
//	}
//	var obj1 = {
//		foo:foo
//	}
//	var obj2 = {};
//	obj1.foo(2);
//	
//	obj1.foo.call(obj2,3);
//	
//	var bar = new obj1.foo(4);
//	console.log(obj1.a)
	
	
	/*
	1.函数是否在new中调用(new 绑定)?如果是的话this绑定是新创建的对象.
		var bar = new foo()
	2.函数是否通过call,apply(显示绑定)或者硬绑定调用?如果是的话,this绑定的是指定的对象
		var bar = foo.call(obj2)
	3.函数是否在某个上下文对象中调用(隐式绑定)? 如果是的话,this绑定的是那个上下文对象.
		var bar = obj1.foo()
	4.如果都不是的话,使用默认绑定.如果在严格模式下,就绑定到undefined,否则绑定到全局对象
		var bar = foo()
	*/
/********************************************************/	
	function foo(a,b,c){
		console.log("a:"+a+",b:"+b+",c:"+c);
	}
	foo.apply(null,[1,2,3]);
	var bar = foo.bind(null,1,2);
	bar(3);
	
	/**************创建this安全区（避免影响其他（第3方库）的this）对象******************/
	/***创建空对象代替null***/
//	var o = Object.create(null)
</script>